<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fightify - Редактор карт</title>
<style>
  /* === Основные стили === */
  body, html {
    margin: 0; padding: 0; height: 100%;
    background: #5e4d53;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #a61241;
    user-select: none;
    -webkit-user-select:none;
    overflow: hidden;
  }
  #container {
    display: flex; flex-direction: column; height: 100vh; padding: 10px;
  }
  h1 {
    margin: 0 0 10px 0; font-weight: 700; text-align: center;
  }

  /* === Верхняя панель управления === */
  #topbar {
    display: flex; gap: 12px; align-items: center; justify-content: center;
    margin-bottom: 8px;
  }
  button, select, input[type="file"] {
    background: #a61241;
    border: none;
    color: #f0f0f0;
    font-weight: 700;
    padding: 8px 14px;
    cursor: pointer;
    border-radius: 4px;
    transition: background-color 0.3s ease;
    font-size: 14px;
  }
  button:hover, select:hover, input[type="file"]:hover {
    background: #8f1037;
  }
  select {
    user-select: auto;
  }

  /* === Редактор нот === */
  #editorArea {
    background: #3d3039;
    flex-grow: 1;
    border-radius: 6px;
    position: relative;
    overflow: hidden;
    cursor: crosshair;
    box-shadow: inset 0 0 15px #a6124144;
  }

  /* === Зона нажатия справа === */
  #hitZone {
    position: absolute;
    top: 0; right: 100px;
    width: 60px; height: 100%;
    border-left: 2px solid #a61241cc;
    pointer-events: none;
  }

  /* === Ноты === */
  .note {
    position: absolute;
    width: 40px; height: 40px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 900;
    font-size: 18px;
    color: white;
    user-select: none;
    text-shadow: 0 0 4px #000000cc;
    box-shadow: 0 0 10px #a61241bb;
    transition: opacity 0.5s ease;
  }
  .note.A { background: #e94a4a; }
  .note.S { background: #e9a54a; }
  .note.D { background: #4ae994; }
  .note.F { background: #4a81e9; }
  .note.MOUSE { background: #b44ae9; font-size: 22px; }

  /* === Нижняя панель аудио === */
  #audiobar {
    margin-top: 10px;
    display: flex;
    align-items: center;
    gap: 10px;
    justify-content: center;
  }
  #audioSlider {
    width: 60%;
    cursor: pointer;
    -webkit-appearance: none;
    height: 6px;
    border-radius: 3px;
    background: #a61241aa;
  }
  #audioSlider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px; height: 16px;
    border-radius: 50%;
    background: #a61241;
    cursor: pointer;
    border: none;
    margin-top: -5px;
  }
  #audioSlider::-moz-range-thumb {
    width: 16px; height: 16px;
    border-radius: 50%;
    background: #a61241;
    cursor: pointer;
    border: none;
  }

  /* Подсказка выбранной клавиши */
  #selectedKey {
    font-weight: 900;
    font-size: 18px;
    padding: 0 6px;
    color: white;
    text-shadow: 0 0 8px #a61241cc;
  }
</style>
</head>
<body>
<div id="container">
  <h1>Fightify — Редактор карт</h1>
  <div id="topbar">
    <input id="fileLoader" type="file" accept="audio/*" />
    <button id="playPauseBtn" disabled>Play ▶️</button>
    <button id="modeBtn" disabled>Режим: Редактор</button>
    <select id="keySelector" title="Выберите клавишу для новой ноты">
      <option value="A">A</option>
      <option value="S">S</option>
      <option value="D">D</option>
      <option value="F">F</option>
      <option value="MOUSE">ПКМ</option>
    </select>
    <span id="selectedKey">A</span>
  </div>
  <div id="editorArea">
    <div id="hitZone"></div>
  </div>
  <div id="audiobar">
    <input type="range" id="audioSlider" min="0" max="100" value="0" step="0.1" />
    <span id="timeDisplay">00:00 / 00:00</span>
  </div>
</div>

<audio id="audioTrack" preload="auto"></audio>

<script>
(() => {
  // Constants
  const noteWidth = 40;
  const noteHeight = 40;
  const hitZoneX = 700; // позиция зоны нажатия по X (px) в редакторе
  const editorWidth = 800; // ширина editorArea (px)
  const editorHeight = 400; // высота editorArea (px)
  const noteSpeed = 150; // пикселей в секунду, скорость движения нот слева направо (чем больше, тем быстрее)

  // DOM Elements
  const fileLoader = document.getElementById('fileLoader');
  const audioTrack = document.getElementById('audioTrack');
  const playPauseBtn = document.getElementById('playPauseBtn');
  const modeBtn = document.getElementById('modeBtn');
  const keySelector = document.getElementById('keySelector');
  const selectedKeySpan = document.getElementById('selectedKey');
  const editorArea = document.getElementById('editorArea');
  const hitZone = document.getElementById('hitZone');
  const audioSlider = document.getElementById('audioSlider');
  const timeDisplay = document.getElementById('timeDisplay');

  // Размеры и стили editorArea
  editorArea.style.width = editorWidth + 'px';
  editorArea.style.height = editorHeight + 'px';

  // Состояния
  let notes = []; // {id, key, time, y, element, hit}
  let mode = 'editor'; // editor / test
  let animationFrameId = null;
  let lastTimestamp = null;
  let isPlaying = false;

  // Для подсчёта времени и id нот
  let nextNoteId = 1;

  // Обновление выбранной клавиши
  keySelector.addEventListener('change', () => {
    selectedKeySpan.textContent = keySelector.value === 'MOUSE' ? 'ПКМ' : keySelector.value;
  });

  // Загрузка аудио
  fileLoader.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    audioTrack.src = url;
    audioTrack.load();
    audioTrack.currentTime = 0;
    playPauseBtn.disabled = false;
    modeBtn.disabled = false;
    resetEditor();
  });

  // Воспроизведение / пауза
  playPauseBtn.addEventListener('click', () => {
    if (!audioTrack.src) return;
    if (isPlaying) {
      audioTrack.pause();
    } else {
      audioTrack.play();
    }
  });

  audioTrack.addEventListener('play', () => {
    isPlaying = true;
    playPauseBtn.textContent = 'Pause ⏸️';
    if (mode === 'test') {
      startAnimation();
    }
  });
  audioTrack.addEventListener('pause', () => {
    isPlaying = false;
    playPauseBtn.textContent = 'Play ▶️';
    stopAnimation();
  });
  audioTrack.addEventListener('ended', () => {
    isPlaying = false;
    playPauseBtn.textContent = 'Play ▶️';
    stopAnimation();
  });

  // Обновление слайдера и времени
  audioTrack.addEventListener('timeupdate', () => {
    if (!audioTrack.duration) return;
    const val = (audioTrack.currentTime / audioTrack.duration) * 100;
    audioSlider.value = val;
    updateTimeDisplay();
  });

  audioSlider.addEventListener('input', () => {
    if (!audioTrack.duration) return;
    const time = (audioSlider.value / 100) * audioTrack.duration;
    audioTrack.currentTime = time;
    if (mode === 'test') renderNotes();
  });

  // Обновление времени отображения
  function updateTimeDisplay() {
    const ct = audioTrack.currentTime;
    const dur = audioTrack.duration || 0;
    timeDisplay.textContent = formatTime(ct) + ' / ' + formatTime(dur);
  }
  function formatTime(t) {
    if (!t) return '00:00';
    const m = Math.floor(t / 60);
    const s = Math.floor(t % 60);
    return (m < 10 ? '0'+m : m) + ':' + (s < 10 ? '0'+s : s);
  }

  // Переключение режимов
  modeBtn.addEventListener('click', () => {
    if (mode === 'editor') {
      if (!audioTrack.src) {
        alert('Загрузите аудио трек перед тестом карты.');
        return;
      }
      mode = 'test';
      modeBtn.textContent = 'Режим: Тест';
      editorArea.style.cursor = 'default';
      clearNotesElements();
      renderNotes();
      if (isPlaying) startAnimation();
    } else {
      mode = 'editor';
      modeBtn.textContent = 'Режим: Редактор';
      editorArea.style.cursor = 'crosshair';
      stopAnimation();
      clearNotesElements();
      renderNotes();
    }
  });

  // Добавление ноты при клике в редакторе (только в режиме редактора)
  editorArea.addEventListener('contextmenu', e => e.preventDefault());

  editorArea.addEventListener('mousedown', e => {
    if (mode !== 'editor') return;
    // Определяем нажатую клавишу: мышь ПКМ или выбранная на селекте
    let key = keySelector.value;
    if (e.button === 2) key = 'MOUSE';
    else if (e.button !== 0) return; // добавляем ноты только ЛКМ или ПКМ

    const rect = editorArea.getBoundingClientRect();
    const x = e.clientX - rect.left;
    if (x > editorWidth - 100) return; // запрет добавлять в зоне нажатия справа

    const y = e.clientY - rect.top;
    const time = audioTrack.currentTime + (hitZoneX - x) / noteSpeed;

    if (time < 0) return; // не добавляем ноты в прошлое

    addNote(key, time, y);
  });

  // Добавляем ноту в массив и на экран
  function addNote(key, time, y) {
    const id = nextNoteId++;
    const note = {
      id,
      key,
      time,
      y: Math.min(Math.max(y, noteHeight/2), editorHeight - noteHeight/2),
      hit: false,
      element: null,
      opacity: 1,
    };
    notes.push(note);
    if (mode === 'editor') {
      createNoteElement(note);
      sortNotesByTime();
    }
  }

  // Создаём DOM элемент ноты для редактора
  function createNoteElement(note) {
    const el = document.createElement('div');
    el.classList.add('note', note.key);
    el.style.top = (note.y - noteHeight/2) + 'px';
    el.style.left = ((note.time - audioTrack.currentTime) * noteSpeed) + 'px';
    el.textContent = note.key === 'MOUSE' ? '🖱️' : note.key;
    editorArea.appendChild(el);
    note.element = el;
  }

  // Обновляем позиции нот в редакторе
  function updateEditorNotes() {
    const now = audioTrack.currentTime;
    notes.forEach(note => {
      if (!note.element) return;
      const x = (note.time - now) * noteSpeed;
      if (x < -noteWidth) {
        note.element.style.display = 'none';
      } else {
        note.element.style.display = 'flex';
        note.element.style.left = x + 'px';
      }
    });
  }

  // Сортируем ноты по времени (возрастание)
  function sortNotesByTime() {
    notes.sort((a,b) => a.time - b.time);
  }

  // Удаляем все DOM элементы нот
  function clearNotesElements() {
    notes.forEach(note => {
      if (note.element) {
        note.element.remove();
        note.element = null;
      }
    });
  }

  // === Тестовый режим ===
  // Создаём и отображаем ноты, которые двигаются слева направо к hitZone
  // При наведении и нажатии правильной клавиши нота плавно исчезает и удаляется

  function renderNotes() {
    clearNotesElements();
    notes.forEach(note => {
      note.opacity = 1;
      note.hit = false;
      createNoteElement(note);
    });
    updateTestNotesPositions();
  }

  function updateTestNotesPositions() {
    const now = audioTrack.currentTime;
    notes.forEach(note => {
      if (!note.element) return;
      const timeDiff = note.time - now;
      const x = timeDiff * noteSpeed;
      if (x < -noteWidth) {
        note.element.style.display = 'none';
      } else {
        note.element.style.display = 'flex';
        note.element.style.left = x + 'px';
      }
    });
  }

  // Анимация теста
  function animationStep(ts) {
    if (!lastTimestamp) lastTimestamp = ts;
    const dt = (ts - lastTimestamp) / 1000;
    lastTimestamp = ts;

    const now = audioTrack.currentTime;

    notes.forEach(note => {
      if (!note.element) return;
      if (note.hit) {
        note.opacity -= dt * 2; // плавное исчезновение (0.5 сек)
        if (note.opacity <= 0) {
          note.element.remove();
          note.element = null;
          note.hit = 'removed';
        } else {
          note.element.style.opacity = note.opacity;
        }
      } else {
        const timeDiff = note.time - now;
        const x = timeDiff * noteSpeed;
        if (x < -noteWidth) {
          // Удаляем просроченную ноту, если не нажали
          note.element.remove();
          note.element = null;
          note.hit = 'missed';
        } else {
          note.element.style.left = x + 'px';
          note.element.style.opacity = 1;
        }
      }
    });

    // Фильтруем удалённые и пропущенные ноты из массива
    notes = notes.filter(n => n.hit !== 'removed' && n.hit !== 'missed');

    animationFrameId = requestAnimationFrame(animationStep);
  }
  function startAnimation() {
    if (!animationFrameId) {
      lastTimestamp = null;
      animationFrameId = requestAnimationFrame(animationStep);
    }
  }
  function stopAnimation() {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
      lastTimestamp = null;
    }
  }

  // Обработка нажатий клавиш для теста
  window.addEventListener('keydown', e => {
    if (mode !== 'test' || !isPlaying) return;
    const keyPressed = e.key.toUpperCase();
    if (!['A','S','D','F'].includes(keyPressed)) return;
    hitNoteByKey(keyPressed);
  });

  // Обработка наведения и клика мыши по нотам ПКМ (MOUSE)
  editorArea.addEventListener('mousemove', e => {
    if (mode !== 'test' || !isPlaying) return;
    const rect = editorArea.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    notes.forEach(note => {
      if (note.key !== 'MOUSE' || note.hit) return;
      if (!note.element) return;
      const noteX = parseFloat(note.element.style.left);
      const noteY = note.y - noteHeight/2;
      if (mouseX >= noteX && mouseX <= noteX + noteWidth && mouseY >= noteY && mouseY <= noteY + noteHeight) {
        note.element.style.filter = 'brightness(1.5)';
      } else {
        note.element.style.filter = '';
      }
    });
  });
  editorArea.addEventListener('mousedown', e => {
    if (mode !== 'test' || !isPlaying) return;
    if (e.button !== 2) return; // только ПКМ для нот MOUSE
    e.preventDefault();
    const rect = editorArea.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    notes.forEach(note => {
      if (note.key !== 'MOUSE' || note.hit) return;
      if (!note.element) return;
      const noteX = parseFloat(note.element.style.left);
      const noteY = note.y - noteHeight/2;
      if (mouseX >= noteX && mouseX <= noteX + noteWidth && mouseY >= noteY && mouseY <= noteY + noteHeight) {
        hitNote(note);
      }
    });
  });

  // Функция для обработки попадания по ноте по клавише
  function hitNoteByKey(key) {
    // ищем ближайшую ноту по времени, которая не нажата и совпадает с key, и которая в зоне попадания
    // зона попадания - ноты с x в районе hitZoneX ± 40px
    const now = audioTrack.currentTime;
    const zoneLeft =  hitZoneX - 40;
    const zoneRight = hitZoneX + 40;

    let candidate = null;
    let candidateDist = Infinity;
    notes.forEach(note => {
      if (note.hit || note.key !== key) return;
      if (!note.element) return;
      const x = parseFloat(note.element.style.left);
      if (x >= zoneLeft && x <= zoneRight) {
        const dist = Math.abs(x - hitZoneX);
        if (dist < candidateDist) {
          candidateDist = dist;
          candidate = note;
        }
      }
    });
    if (candidate) hitNote(candidate);
  }

  // Помечаем ноту как нажатую и запускаем анимацию исчезновения
  function hitNote(note) {
    note.hit = true;
    note.element.style.filter = 'brightness(2)';
  }

  // Сброс редактора
  function resetEditor() {
    notes = [];
    clearNotesElements();
    audioSlider.value = 0;
    timeDisplay.textContent = '00:00 / 00:00';
    mode = 'editor';
    modeBtn.textContent = 'Режим: Редактор';
    editorArea.style.cursor = 'crosshair';
  }

})();
</script>
</body>
</html>

